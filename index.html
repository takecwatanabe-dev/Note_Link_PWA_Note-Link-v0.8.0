<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Note Link v0.7.2-compat / No.14</title>
<meta name="theme-color" content="#0a0a0a" />
<style>
  :root{
    /* v0.7 の落ち着いた濃色基調を踏襲 */
    --bg-900:#0b0b0b; --bg-850:#141414; --bg-800:#1c1c1c;
    --bd-700:#343434; --tx-100:#f5f5f5; --tx-300:#cfcfcf;
    --green:#22c55e; --shadow:0 10px 24px rgba(0,0,0,.35), 0 2px 8px rgba(0,0,0,.25);
    --panel-w:300px;  /* v0.7系の控えめ幅 */
    --btn:40px;       /* v0.7のアイコンボタン寸法 */
    --icon:22px;      /* v0.7のアイコン実寸 */
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  [hidden]{display:none !important;} /* パネルのチラ見え防止（v0.7との見た目差なし） */
  body{
    margin:0; background:var(--bg-900); color:var(--tx-100);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    touch-action:manipulation; -webkit-tap-highlight-color:transparent;
  }
  .app{display:grid; grid-template-rows:auto 1fr; height:100%;
       padding-top:env(safe-area-inset-top); padding-bottom:env(safe-area-inset-bottom);}
  /* ===== ツールバー（v0.7準拠） ===== */
  header.toolbar{
    position:relative; z-index:10; width:100%;
    background:#0e0e0e; border-bottom:1px solid var(--bd-700);
  }
  .toolbar-row{display:flex; align-items:center; gap:8px; padding:8px 10px; overflow-x:auto; white-space:nowrap;}
  .title{font-weight:700; font-size:.95rem; margin-right:10px; flex:0 0 auto;}
  .tool-btn{
    flex:0 0 auto; width:var(--btn); height:var(--btn);
    border-radius:10px; background:transparent; border:1px solid transparent; color:var(--tx-100);
    display:grid; place-items:center; cursor:pointer; user-select:none;
    transition:background .12s ease, border-color .12s ease, transform .02s ease;
  }
  .tool-btn:hover{background:#171717} .tool-btn:active{transform:scale(.98)}
  .tool-btn[aria-pressed="true"]{outline:none}
  .tool-btn.is-open{border:2px solid var(--green)} /* 開いている間だけ緑枠 */
  .icon{width:var(--icon); height:var(--icon); display:block}
  .zoom-btn{min-width:60px; font-weight:700} /* 100% 表示 */
  /* ===== パネル（UI配置は踏襲／外側タップで閉じない） ===== */
  .panel{
    position:fixed; width:var(--panel-w);
    background:var(--bg-800); border:1px solid var(--bd-700); border-radius:12px; box-shadow:var(--shadow); z-index:1000;
  }
  .panel-inner{padding:12px}
  .panel h3{margin:0 0 8px 0; font-size:.95rem}
  .panel .row{display:flex; align-items:center; justify-content:space-between; gap:12px; margin:8px 0}
  .panel label{font-size:.9rem; color:var(--tx-300)}
  .panel input[type="range"]{width:60%}
  .btn, .btn-close{
    display:block; width:100%; margin-top:10px; border-radius:10px; border:1px solid var(--bd-700);
    background:transparent; color:var(--tx-100); padding:9px 10px; cursor:pointer;
  }
  .btn:hover,.btn-close:hover{background:#2a2a2a}
  /* ===== 作業領域（ズームはCSS transform） ===== */
  main.workspace{position:relative; width:100%; height:100%; background:var(--bg-850); overflow:hidden}
  .viewport{position:absolute; left:0; top:0; transform-origin:0 0;}
  canvas{position:absolute; left:0; top:0; display:block}
  #overlay{pointer-events:none}
  /* グリッド（見た目のみ。スナップは無効） */
  .workspace.grid-on{
    background:
      linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px) 0 0/24px 24px,
      linear-gradient(90deg, rgba(255,255,255,.04) 1px, transparent 1px) 0 0/24px 24px,
      var(--bg-850);
  }
</style>
</head>
<body>
<div class="app">
  <header class="toolbar" role="toolbar" aria-label="Note Link toolbar">
    <div class="toolbar-row" id="toolbarRow">
      <div class="title" id="appTitle">Note Link v0.7.2-compat / No.14</div>

      <!-- v0.7準拠のボタン群：順序とおおよそのサイズを踏襲 -->
      <button class="tool-btn" id="penBtn" title="ペン" aria-pressed="true">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25Zm18-11.5a1 1 0 0 0 0-1.41l-1.59-1.59a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75L21 5.75Z" fill="currentColor"/></svg>
      </button>
      <button class="tool-btn" id="markerBtn" title="マーカー" aria-pressed="false">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 15l6 6 12-12-6-6L3 15Zm0 0l-1 5 5-1" fill="currentColor"/></svg>
      </button>
      <button class="tool-btn" id="lineBtn" title="直線" aria-pressed="false">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20 L20 4" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
      </button>
      <button class="tool-btn" id="eraserBtn" title="消しゴム" aria-pressed="false">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M16 3 21 8 9 20H4L16 8zM3 21h18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </button>
      <button class="tool-btn" id="gridBtn" title="グリッド表示" aria-pressed="false">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 3h18v18H3zM9 3v18M15 3v18M3 9h18M3 15h18" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <!-- ズーム表示（ボタン内に%） -->
      <button class="tool-btn zoom-btn" id="zoomDisplay" title="ズーム率">100%</button>

      <!-- キーボード -->
      <button class="tool-btn" id="kbdBtn" title="キーボード" aria-pressed="false" aria-haspopup="dialog" aria-controls="kbdPanel">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 6h18v12H3z M5 9h2 M8 9h2 M11 9h2 M14 9h2 M17 9h2 M5 12h2 M8 12h2 M11 12h2 M14 12h2 M17 12h2 M5 15h10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </button>

      <!-- 設定 -->
      <button class="tool-btn" id="settingsBtn" title="設定" aria-pressed="false" aria-haspopup="dialog" aria-controls="settingsPanel">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 8a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm8.9 3a8.3 8.3 0 0 0-.1-1l2-1.5-1.8-3.2-2.4.5a7.7 7.7 0 0 0-1.5-.9l-.4-2.4H7.3l-.4 2.4a7.7 7.7 0 0 0-1.5.9l-2.4-.5L1.2 8.1 3.2 9.6a8.3 8.3 0 0 0 0 2L1.2 13l1.8 3.2 2.4-.5c.5.4 1 .7 1.5.9l.4 2.4h6.4l.4-2.4c.5-.2 1-.5 1.5-.9l2.4.5 1.8-3.2-2-1.5c.1-.3.1-.7.1-1Z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>
    </div>
  </header>

  <!-- 作業領域（v0.7と同じ1面キャンバス） -->
  <main class="workspace" id="workspace" tabindex="-1" aria-label="作業領域">
    <div class="viewport" id="viewport">
      <canvas id="canvas"></canvas>
      <canvas id="overlay"></canvas>
    </div>
  </main>
</div>

<!-- パネル（body直下・固定位置。外側タップでは閉じない） -->
<div class="panel" id="kbdPanel" role="dialog" aria-modal="false" hidden>
  <div class="panel-inner" onclick="event.stopPropagation()" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
    <h3>キーボード設定</h3>
    <div class="row">
      <label for="fontSize">文字サイズ</label>
      <input type="range" id="fontSize" min="8" max="48" step="1" value="14" />
    </div>
    <div class="row"><span id="fontSizeLabel">14 pt（18.7 px）</span></div>
    <button type="button" class="btn-close" id="kbdClose">閉じる</button>
  </div>
</div>

<div class="panel" id="settingsPanel" role="dialog" aria-modal="false" hidden>
  <div class="panel-inner" onclick="event.stopPropagation()" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
    <h3>設定</h3>
    <div class="row">
      <label for="penSize">ペン太さ</label>
      <input type="range" id="penSize" min="1" max="20" step="0.5" value="2" />
    </div>
    <div class="row"><span id="penSizeLabel">2.0 px（0.53 mm）</span></div>
    <div class="row"><button type="button" class="btn" id="fullscreenBtn">全画面にする</button></div>
    <button type="button" class="btn-close" id="settingsClose">閉じる</button>
  </div>
</div>

<script>
/* ==========================
   v0.7.2-compat フル実装
========================== */
const cssDPI = 96, $=q=>document.querySelector(q);
const els={
  title:$('#appTitle'), toolbar:$('#toolbarRow'),
  workspace:$('#workspace'), viewport:$('#viewport'),
  canvas:$('#canvas'), overlay:$('#overlay'),
  penBtn:$('#penBtn'), markerBtn:$('#markerBtn'), lineBtn:$('#lineBtn'),
  eraserBtn:$('#eraserBtn'), handBtn:$('#handBtn'), gridBtn:$('#gridBtn'),
  zoomDisplay:$('#zoomDisplay'),
  settingsBtn:$('#settingsBtn'), settingsPanel:$('#settingsPanel'), settingsClose:$('#settingsClose'),
  kbdBtn:$('#kbdBtn'), kbdPanel:$('#kbdPanel'), kbdClose:$('#kbdClose'),
  penSize:$('#penSize'), penSizeLabel:$('#penSizeLabel'),
  fontSize:$('#fontSize'), fontSizeLabel:$('#fontSizeLabel'),
  fullscreenBtn:$('#fullscreenBtn')
};

const app={
  tool:'pen', grid:false,
  scale:1, minScale:.25, maxScale:4, step:.1,
  panX:0, panY:0,
  penSizePx:2, fontPt:14,
  strokes:[], drawing:false, current:null, lineStart:null, handStart:null, pinch:null
};

const ctx=els.canvas.getContext('2d'), octx=els.overlay.getContext('2d');

/* ===== レイアウト ===== */
function fitCanvas(){
  const r=els.workspace.getBoundingClientRect();
  const d=Math.max(1, window.devicePixelRatio||1);
  [els.canvas, els.overlay].forEach(cv=>{
    const need=cv.width!==Math.floor(r.width*d)||cv.height!==Math.floor(r.height*d);
    if(need){
      cv.width=Math.floor(r.width*d); cv.height=Math.floor(r.height*d);
      cv.style.width=r.width+'px'; cv.style.height=r.height+'px';
    }
  });
  drawAll(); clearOverlay();
}
function applyView(){
  els.viewport.style.transformOrigin='0 0';
  els.viewport.style.transform=`translate(${app.panX}px,${app.panY}px) scale(${app.scale})`;
  if (els.zoomDisplay) els.zoomDisplay.textContent = Math.round(app.scale*100) + '%';
}

/* ===== 単位表記 ===== */
function pxToMm(px){ return px * 25.4 / cssDPI; }
function pxToPt(px){ return px * 72 / cssDPI; }
function updatePenLabel(){
  if (!els.penSizeLabel) return;
  els.penSizeLabel.textContent = `${app.penSizePx.toFixed(1)} px（${pxToMm(app.penSizePx).toFixed(2)} mm）`;
}
function updateFontLabel(){
  if (!els.fontSizeLabel) return;
  const px = app.fontPt * cssDPI / 72;
  els.fontSizeLabel.textContent = `${app.fontPt} pt（${px.toFixed(1)} px）`;
}

/* ===== 座標/描画 ===== */
const clear=c=>c.clearRect(0,0,c.canvas.width,c.canvas.height);
const clearOverlay=()=>clear(octx);
const worldToScreen=p=>({x:p.x*app.scale+app.panX,y:p.y*app.scale+app.panY});
const screenToWorld=p=>({x:(p.x-app.panX)/app.scale,y:(p.y-app.panY)/app.scale});

function drawStroke(st){
  ctx.save();
  const d=Math.max(1, window.devicePixelRatio||1); ctx.scale(d,d);
  ctx.lineCap='round'; ctx.lineJoin='round';
  ctx.globalAlpha = st.alpha ?? 1;
  ctx.globalCompositeOperation = st.comp || 'source-over';
  ctx.strokeStyle = st.color || '#fff';
  ctx.lineWidth = st.w || 2;
  if (st.type==='free' || st.type==='marker' || st.type==='eraser'){
    ctx.beginPath();
    st.pts.forEach((pt,i)=>{ const s=worldToScreen(pt); if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); });
    ctx.stroke();
  } else if (st.type==='line'){
    const a=worldToScreen(st.a), b=worldToScreen(st.b);
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  ctx.restore();
}
function drawAll(){ clear(ctx); app.strokes.forEach(drawStroke); }
function drawPreview(pre){
  clearOverlay(); if (!pre) return;
  const d=Math.max(1, window.devicePixelRatio||1); octx.save(); octx.scale(d,d);
  octx.lineCap='round'; octx.lineJoin='round'; octx.setLineDash([6,6]);
  octx.strokeStyle='#7ec8ff'; octx.lineWidth=app.penSizePx; octx.globalAlpha=.9;
  if (pre.type==='line'){
    const a=worldToScreen(pre.a), b=worldToScreen(pre.b);
    octx.beginPath(); octx.moveTo(a.x,a.y); octx.lineTo(b.x,b.y); octx.stroke();
    // 角度表記：x正=0°, CCW=＋, CW=－
    const ang = Math.atan2(pre.b.y-pre.a.y, pre.b.x-pre.a.x) * 180/Math.PI;
    const m = {x:(a.x+b.x)/2, y:(a.y+b.y)/2};
    octx.setLineDash([]); octx.font='12px system-ui,sans-serif';
    octx.strokeStyle='rgba(0,0,0,.6)'; octx.lineWidth=3; octx.strokeText(ang.toFixed(1)+'°', m.x+8, m.y-8);
    octx.fillStyle='#fff'; octx.fillText(ang.toFixed(1)+'°', m.x+8, m.y-8);
  }
  octx.restore();
}

/* ===== 入力処理 ===== */
function setTool(t){
  app.tool=t;
  [['pen',els.penBtn],['marker',els.markerBtn],['line',els.lineBtn],['eraser',els.eraserBtn],['hand',els.handBtn]]
    .forEach(([name,b])=>{ if(b) b.setAttribute('aria-pressed', name===t?'true':'false'); });
}
function getPt(e){
  if (e.touches && e.touches[0]) return {x:e.touches[0].clientX, y:e.touches[0].clientY};
  if (e.changedTouches && e.changedTouches[0]) return {x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY};
  return {x:e.clientX, y:e.clientY};
}
function begin(world){
  app.drawing = true;
  if (app.tool==='pen' || app.tool==='marker' || app.tool==='eraser'){
    app.current = {
      type: app.tool==='eraser'?'eraser': (app.tool==='marker'?'marker':'free'),
      pts:[world], w:app.penSizePx, color:'#fff',
      alpha: app.tool==='marker'?0.6:1,
      comp:  app.tool==='eraser'?'destination-out':'source-over'
    };
  } else if (app.tool==='line'){
    app.lineStart = world;
  } else if (app.tool==='hand'){
    app.handStart = {x:world.x, y:world.y, panX:app.panX, panY:app.panY};
  }
}
function move(world){
  if (!app.drawing) return;
  if (app.tool==='pen' || app.tool==='marker' || app.tool==='eraser'){
    app.current.pts.push(world);
    const pts=app.current.pts;
    if (pts.length>=3){ const n=pts.length, p0=pts[n-3], p1=pts[n-2], p2=pts[n-1]; p1.x=(p0.x+p1.x+p2.x)/3; p1.y=(p0.y+p1.y+p2.y)/3; }
    drawAll(); clearOverlay();
  } else if (app.tool==='line'){
    drawAll(); drawPreview({type:'line', a:app.lineStart, b:world});
  } else if (app.tool==='hand'){
    const dx=(world.x-app.handStart.x)*app.scale, dy=(world.y-app.handStart.y)*app.scale;
    app.panX = app.handStart.panX + dx; app.panY = app.handStart.panY + dy;
    applyView();
  }
}
function end(world){
  if (!app.drawing) return;
  if (app.tool==='pen' || app.tool==='marker' || app.tool==='eraser'){
    app.strokes.push(app.current); app.current=null; saveSnapshot();
  } else if (app.tool==='line'){
    app.strokes.push({type:'line', a:app.lineStart, b:world, w:app.penSizePx, color:'#fff', alpha:1});
    app.lineStart=null; clearOverlay(); saveSnapshot();
  }
  app.drawing=false;
}

/* ===== ズーム（Ctrl+ホイール／ピンチ） ===== */
function setScale(next, center){
  app.scale = Math.max(app.minScale, Math.min(app.maxScale, next));
  if (center){
    const before=screenToWorld(center); applyView(); const after=screenToWorld(center);
    app.panX += (after.x-before.x)*app.scale; app.panY += (after.y-before.y)*app.scale;
  }
  applyView();
}
function onWheel(e){ if(!e.ctrlKey) return; e.preventDefault(); const d=-Math.sign(e.deltaY)*app.step; setScale(app.scale+d, {x:e.clientX,y:e.clientY}); }
function onTouchStart(e){
  if (e.touches.length===2){
    const [a,b]=e.touches, dx=b.clientX-a.clientX, dy=b.clientY-a.clientY;
    app.pinch={d:Math.hypot(dx,dy), cx:(a.clientX+b.clientX)/2, cy:(a.clientY+b.clientY)/2, start:app.scale};
  } else if (e.touches.length===1){
    begin(screenToWorld(getPt(e)));
  }
}
function onTouchMove(e){
  if (app.pinch && e.touches.length===2){
    const [a,b]=e.touches, dx=b.clientX-a.clientX, dy=b.clientY-a.clientY;
    const d=Math.hypot(dx,dy); setScale(app.pinch.start*(d/app.pinch.d), {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2});
  } else if (app.drawing && e.touches.length===1){
    move(screenToWorld(getPt(e)));
  }
}
function onTouchEnd(e){
  if (app.pinch && e.touches.length<2) app.pinch=null;
  if (app.drawing) end(screenToWorld(getPt(e)));
}

/* ===== グリッド（見た目のみ・スナップ無効） ===== */
function toggleGrid(){
  app.grid = !app.grid;
  els.gridBtn.setAttribute('aria-pressed', app.grid?'true':'false');
  els.workspace.classList.toggle('grid-on', app.grid);
}

/* ===== 永続化（IndexedDB） ===== */
const DB='notelink-db', STORE='doc', KEY='latest';
function idbOpen(){return new Promise((ok,ng)=>{const r=indexedDB.open(DB,1);
  r.onupgradeneeded=e=>{const db=e.target.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);};
  r.onsuccess=()=>ok(r.result); r.onerror=()=>ng(r.error);
});}
async function idbSet(v){try{const db=await idbOpen(); const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(v,KEY);
  await new Promise((ok,ng)=>{tx.oncomplete=ok; tx.onerror=()=>ng(tx.error)}); db.close();}catch{}}
async function idbGet(){try{const db=await idbOpen(); const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).get(KEY);
  const v=await new Promise((ok,ng)=>{req.onsuccess=()=>ok(req.result); req.onerror=()=>ng(req.error)}); db.close(); return v;}catch{return null}}
function saveSnapshot(){ idbSet(JSON.stringify({strokes:app.strokes, scale:app.scale, panX:app.panX, panY:app.panY, penSizePx:app.penSizePx, fontPt:app.fontPt})); }
async function restoreSnapshot(){
  const raw = await idbGet(); if (!raw) return;
  try{
    const s=JSON.parse(raw);
    app.strokes=s.strokes||[]; app.scale=s.scale??1; app.panX=s.panX??0; app.panY=s.panY??0;
    app.penSizePx=s.penSizePx??2; if (els.penSize) els.penSize.value=app.penSizePx;
    app.fontPt=s.fontPt??14; if (els.fontSize) els.fontSize.value=app.fontPt;
    updatePenLabel(); updateFontLabel(); applyView(); drawAll();
  }catch{}
}
document.addEventListener('visibilitychange',()=>{ if(document.visibilityState==='hidden') saveSnapshot(); });
window.addEventListener('pagehide', saveSnapshot);
window.addEventListener('pageshow', restoreSnapshot);

/* ===== パネル（トグル・外側タップで閉じない・開いてる間は緑枠） ===== */
function placePanel(panel, trigger){
  const r=trigger.getBoundingClientRect(), gap=8, w=parseInt(getComputedStyle(panel).width||300,10);
  let left=Math.max(8, Math.min(r.right-w, window.innerWidth-w-8));
  let top=Math.min(r.bottom+gap, window.innerHeight-panel.offsetHeight-8);
  panel.style.left=left+'px'; panel.style.top=Math.max(8, top)+'px';
}
function openPanel(btn, panel){ btn.setAttribute('aria-pressed','true'); btn.classList.add('is-open'); panel.hidden=false; placePanel(panel, btn); }
function closePanel(btn, panel){ btn.setAttribute('aria-pressed','false'); btn.classList.remove('is-open'); panel.hidden=true; }
function togglePanel(btn, panel){ const open=btn.getAttribute('aria-pressed')==='true'; open?closePanel(btn,panel):openPanel(btn,panel); }
['click','mousedown','touchstart'].forEach(t=>{
  els.settingsPanel && els.settingsPanel.addEventListener(t, ev=>ev.stopPropagation(), {passive:true});
  els.kbdPanel && els.kbdPanel.addEventListener(t, ev=>ev.stopPropagation(), {passive:true});
});

/* ===== フルスクリーン ===== */
els.fullscreenBtn && els.fullscreenBtn.addEventListener('click', async ()=>{
  try{
    if (!document.fullscreenElement){ await document.documentElement.requestFullscreen(); els.fullscreenBtn.textContent='全画面を終了'; }
    else { await document.exitFullscreen(); els.fullscreenBtn.textContent='全画面にする'; }
  }catch{}
});

/* ===== イベント配線 ===== */
window.addEventListener('resize', ()=>{ fitCanvas(); if(els.settingsBtn?.getAttribute('aria-pressed')==='true') placePanel(els.settingsPanel, els.settingsBtn); if(els.kbdBtn?.getAttribute('aria-pressed')==='true') placePanel(els.kbdPanel, els.kbdBtn); });
els.workspace.addEventListener('wheel', onWheel, {passive:false});
els.workspace.addEventListener('mousedown', e=>begin(screenToWorld(getPt(e))));
window.addEventListener('mousemove', e=>{ if(app.drawing) move(screenToWorld(getPt(e))); });
window.addEventListener('mouseup',   e=>{ if(app.drawing) end(screenToWorld(getPt(e))); });
els.workspace.addEventListener('touchstart', onTouchStart, {passive:true});
els.workspace.addEventListener('touchmove',  onTouchMove,  {passive:true});
els.workspace.addEventListener('touchend',   onTouchEnd,   {passive:true});
els.workspace.addEventListener('touchcancel',onTouchEnd,   {passive:true});

/* ツール切替 */
els.penBtn?.addEventListener('click',   ()=>setTool('pen'));
els.markerBtn?.addEventListener('click',()=>setTool('marker'));
els.lineBtn?.addEventListener('click',  ()=>setTool('line'));
els.eraserBtn?.addEventListener('click',()=>setTool('eraser'));
els.handBtn?.addEventListener('click',  ()=>setTool('hand'));
els.gridBtn?.addEventListener('click',  toggleGrid);

/* パネル */
els.settingsBtn?.addEventListener('click', ()=>togglePanel(els.settingsBtn, els.settingsPanel));
els.settingsClose?.addEventListener('click', ()=>closePanel(els.settingsBtn, els.settingsPanel));
els.kbdBtn?.addEventListener('click', ()=>togglePanel(els.kbdBtn, els.kbdPanel));
els.kbdClose?.addEventListener('click', ()=>closePanel(els.kbdBtn, els.kbdPanel));

/* コントロール */
els.penSize?.addEventListener('input', ()=>{ app.penSizePx=parseFloat(els.penSize.value||'2'); updatePenLabel(); }, {passive:true});
els.fontSize?.addEventListener('input', ()=>{ app.fontPt=parseInt(els.fontSize.value||'14',10); updateFontLabel(); }, {passive:true});

/* ===== 初期化 ===== */
function init(){
  setTool('pen');
  updatePenLabel(); updateFontLabel();
  fitCanvas(); applyView(); restoreSnapshot();
  // 念のため両パネルを閉じ状態で統一
  if (els.settingsBtn){ els.settingsBtn.setAttribute('aria-pressed','false'); els.settingsBtn.classList.remove('is-open'); els.settingsPanel.hidden=true; }
  if (els.kbdBtn){ els.kbdBtn.setAttribute('aria-pressed','false'); els.kbdBtn.classList.remove('is-open'); els.kbdPanel.hidden=true; }
}
init();
</script>
</body>
</html>
