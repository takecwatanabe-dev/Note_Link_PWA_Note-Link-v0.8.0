<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Note Link v0.8.0 / No.06</title>
<meta name="theme-color" content="#0a0a0a" />
<style>
  :root{
    --bg-900:#0a0a0a; --bg-850:#121212; --bg-800:#1f1f1f;
    --bd-700:#3a3a3a; --text-100:#f5f5f5; --text-300:#cfcfcf;
    --green:#22c55e; --shadow:0 10px 24px rgba(0,0,0,.35), 0 2px 8px rgba(0,0,0,.25);
    --panel-w:320px; /* ダイアログ幅トークン（他と統一） */
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text-100); background:var(--bg-900);
    font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    touch-action:manipulation; -webkit-tap-highlight-color:transparent;
  }
  .app{display:grid; grid-template-rows:auto 1fr; height:100%;
       padding-top:env(safe-area-inset-top); padding-bottom:env(safe-area-inset-bottom);}
  /* ===== Toolbar / Title ===== */
  .toolbar{
    position:relative; z-index:10; width:100%;
    background:rgba(10,10,10,.85); border-bottom:1px solid var(--bd-700);
    -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
  }
  .toolbar-row{display:flex; align-items:center; gap:8px; padding:8px; overflow-x:auto; white-space:nowrap;}
  .title{
    font-weight:800; font-size:1.125rem; /* 指示：サイズUP */
    margin-right:12px; flex:0 0 auto;
  }
  .tool-btn{
    flex:0 0 auto; width:44px; height:44px; border-radius:12px;
    border:1px solid transparent; background:transparent; color:var(--text-100);
    display:grid; place-items:center; cursor:pointer; user-select:none;
    transition:background .15s ease, border-color .15s ease, transform .02s ease;
  }
  .tool-btn:hover{background:#161616} .tool-btn:active{transform:scale(.98)}
  .tool-btn.is-open{border:2px solid var(--green)}
  .icon{width:28px; height:28px; display:block} /* 指示：アイコン28px化 */
  /* ===== Settings / Dialog (UIは据え置き、見た目統一) ===== */
  .settings-wrap{position:relative; flex:0 0 auto}
  .panel{
    position:absolute; right:0; top:calc(100% + 8px); width:var(--panel-w);
    border-radius:12px; background:var(--bg-800); border:1px solid var(--bd-700);
    box-shadow:var(--shadow); z-index:50;
  }
  .panel-inner{padding:12px}
  .panel h3{margin:0 0 8px 0; font-size:.95rem}
  .panel .row{display:flex; align-items:center; justify-content:space-between; gap:12px; margin:8px 0}
  .panel label{font-size:.9rem; color:var(--text-300)}
  .panel input[type="range"]{width:60%}
  .btn-close, .btn{
    display:block; width:100%; margin-top:10px; border-radius:10px; border:1px solid var(--bd-700);
    background:transparent; color:var(--text-100); padding:10px 12px; cursor:pointer;
  }
  .btn:hover,.btn-close:hover{background:#2a2a2a}
  /* ===== Workspace / Viewport (ズームはCSS transformで) ===== */
  .workspace{position:relative; width:100%; height:100%; background:var(--bg-850); overflow:hidden}
  .workspace.grid-on{
    background:
      radial-gradient(transparent 1px, rgba(255,255,255,0.04) 1px) 0 0/24px 24px,
      radial-gradient(transparent 1px, rgba(255,255,255,0.03) 1px) 12px 12px/24px 24px;
  }
  .viewport{position:absolute; left:0; top:0; transform-origin:0 0;} /* translate/scaleを当てる */
  canvas{display:block; position:absolute; left:0; top:0}
  #overlay{pointer-events:none} /* プレビュー専用 */
  /* 角度の小さな注記（オーバーレイで描画）→UI配置を増やさない */
  /* ===== Draggable dialog helper ===== */
  .draggable{cursor:move}
  /* ===== Zoom button (％表示のみ／UI配置は据え置き) ===== */
  .zoom-btn{min-width:64px; font-weight:700}
  /* アクセシビリティ用微調整 */
  [aria-pressed="true"]{outline:none}
</style>
</head>
<body>
<div class="app">
  <header class="toolbar" role="toolbar" aria-label="Note Link toolbar">
    <div class="toolbar-row">
      <div class="title" id="appTitle">Note Link v0.8.0 / No.06</div>

      <!-- ツール（ペン／マーカー／直線／手（パン）／グリッド／ズーム％／キーボード／設定） -->
      <button class="tool-btn" id="penBtn" title="ペン" aria-pressed="true">
        <!-- Pen (太線化) -->
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25Zm18-11.5a1 1 0 0 0 0-1.41l-1.59-1.59a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75L21 5.75Z" fill="currentColor"/></svg>
      </button>
      <button class="tool-btn" id="markerBtn" title="マーカー" aria-pressed="false">
        <!-- Marker (stroke太) -->
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 15l6 6 12-12-6-6L3 15Zm0 0l-1 5 5-1" fill="currentColor"/>
        </svg>
      </button>
      <button class="tool-btn" id="lineBtn" title="直線" aria-pressed="false">
        <!-- Line -->
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 20 L20 4" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
        </svg>
      </button>
      <button class="tool-btn" id="handBtn" title="ハンドル（パン）" aria-pressed="false">
        <!-- 手の形のアイコン -->
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7 11V6a1 1 0 1 1 2 0v5M10 11V5a1 1 0 1 1 2 0v6M13 11V4a1 1 0 1 1 2 0v7M16 12V7a1 1 0 1 1 2 0v7M6 12c-2 0-2 2-2 3 0 2 1 6 6 6h3c3 0 5-2 5-5v-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="tool-btn" id="gridBtn" title="グリッド表示" aria-pressed="false">
        <!-- Grid -->
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 3h18v18H3zM9 3v18M15 3v18M3 9h18M3 15h18" fill="none" stroke="currentColor" stroke-width="2"/>
        </svg>
      </button>

      <!-- ズーム％表示（ボタン内に現在値表示） -->
      <button class="tool-btn zoom-btn" id="zoomDisplay" title="ズーム率">100%</button>

      <!-- キーボード（文字サイズpt） -->
      <div class="settings-wrap" id="kbdWrap">
        <button class="tool-btn" id="kbdBtn" title="キーボード" aria-pressed="false" aria-haspopup="dialog" aria-controls="kbdPanel">
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M3 6h18v12H3z M5 9h2 M8 9h2 M11 9h2 M14 9h2 M17 9h2 M5 12h2 M8 12h2 M11 12h2 M14 12h2 M17 12h2 M5 15h10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
        <div class="panel" id="kbdPanel" role="dialog" aria-modal="false" hidden>
          <div class="panel-inner" onclick="event.stopPropagation()" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
            <h3>キーボード設定</h3>
            <div class="row">
              <label for="fontSize">文字サイズ</label>
              <input type="range" id="fontSize" min="8" max="48" step="1" value="14" />
            </div>
            <div class="row"><span id="fontSizeLabel">14 pt（18.7 px）</span></div>
            <button type="button" class="btn-close" id="kbdClose">閉じる</button>
          </div>
        </div>
      </div>

      <!-- 設定（外側タップでは閉じない／フルスクリーン切替） -->
      <div class="settings-wrap" id="settingsWrap">
        <button class="tool-btn" id="settingsBtn" title="設定" aria-pressed="false" aria-haspopup="dialog" aria-controls="settingsPanel">
          <!-- 太線ギア -->
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 8a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm8.9 3a8.3 8.3 0 0 0-.1-1l2-1.5-1.8-3.2-2.4.5a7.7 7.7 0 0 0-1.5-.9l-.4-2.4H7.3l-.4 2.4a7.7 7.7 0 0 0-1.5.9l-2.4-.5L1.2 8.1 3.2 9.6a8.3 8.3 0 0 0 0 2L1.2 13l1.8 3.2 2.4-.5c.5.4 1 .7 1.5.9l.4 2.4h6.4l.4-2.4c.5-.2 1-.5 1.5-.9l2.4.5 1.8-3.2-2-1.5c.1-.3.1-.7.1-1Z" fill="none" stroke="currentColor" stroke-width="2"/>
          </svg>
        </button>
        <div class="panel" id="settingsPanel" role="dialog" aria-modal="false" hidden>
          <div class="panel-inner" onclick="event.stopPropagation()" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
            <h3>設定</h3>
            <div class="row">
              <label for="penSize">ペン太さ</label>
              <input type="range" id="penSize" min="1" max="20" step="0.5" value="2" />
            </div>
            <div class="row"><span id="penSizeLabel">2.0 px（0.53 mm）</span></div>

            <div class="row">
              <button type="button" class="btn" id="fullscreenBtn">全画面にする</button>
            </div>

            <button type="button" class="btn-close" id="settingsClose">閉じる</button>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- ===== Workspace ===== -->
  <main class="workspace" id="workspace" tabindex="-1" aria-label="作業領域">
    <div class="viewport" id="viewport">
      <canvas id="canvas"></canvas>
      <canvas id="overlay"></canvas>
    </div>
  </main>
</div>

<script>
/* ==========================
   基本状態
========================== */
const cssDPI = 96; // CSS基準
const $ = (q)=>document.querySelector(q);
const app = {
  tool: 'pen', // 'pen'|'marker'|'line'|'hand'
  grid: false,
  scale: 1, minScale: .25, maxScale: 4, step: .1,
  panX: 0, panY: 0,
  penSizePx: 2,
  fontPt: 14,
  strokes: [], // 世界座標で保持
  drawing: false,
  currentStroke: null,
  lineStart: null, // {x,y} 世界座標
  pinch: null // {d, cx, cy, startScale}
};

const els = {
  title: $('#appTitle'),
  workspace: $('#workspace'),
  viewport: $('#viewport'),
  canvas: $('#canvas'),
  overlay: $('#overlay'),
  penBtn: $('#penBtn'),
  markerBtn: $('#markerBtn'),
  lineBtn: $('#lineBtn'),
  handBtn: $('#handBtn'),
  gridBtn: $('#gridBtn'),
  zoomDisplay: $('#zoomDisplay'),
  settingsBtn: $('#settingsBtn'),
  settingsPanel: $('#settingsPanel'),
  settingsClose: $('#settingsClose'),
  penSize: $('#penSize'),
  penSizeLabel: $('#penSizeLabel'),
  fullscreenBtn: $('#fullscreenBtn'),
  kbdBtn: $('#kbdBtn'),
  kbdPanel: $('#kbdPanel'),
  kbdClose: $('#kbdClose'),
  fontSize: $('#fontSize'),
  fontSizeLabel: $('#fontSizeLabel')
};

/* ==========================
   レイアウト初期化
========================== */
const ctx = els.canvas.getContext('2d');
const octx = els.overlay.getContext('2d');

function fitCanvas() {
  // CSSサイズを読み取り、内部解像度だけ調整（ズームでは変更しない）
  const rect = els.workspace.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  [els.canvas, els.overlay].forEach(cv=>{
    const needResize = cv.width !== Math.floor(rect.width * dpr) || cv.height !== Math.floor(rect.height * dpr);
    if (needResize) {
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(rect.height * dpr);
      cv.style.width = rect.width + 'px';
      cv.style.height = rect.height + 'px';
    }
  });
  drawAll();
  drawOverlay(); // 消し
}

function applyViewTransform() {
  const t = `translate(${app.panX}px, ${app.panY}px) scale(${app.scale})`;
  els.viewport.style.transform = t;
  els.zoomDisplay.textContent = Math.round(app.scale * 100) + '%';
}

/* ==========================
   単位換算表示
========================== */
function pxToMm(px){ return px * 25.4 / cssDPI; }
function pxToPt(px){ return px * 72 / cssDPI; }
function mmToLabel(mm){ return mm.toFixed(2); }
function updatePenLabel(){
  const mm = pxToMm(app.penSizePx);
  els.penSizeLabel.textContent = `${app.penSizePx.toFixed(1)} px（${mmToLabel(mm)} mm）`;
}
function updateFontLabel(){
  const px = app.fontPt * cssDPI / 72;
  els.fontSizeLabel.textContent = `${app.fontPt} pt（${px.toFixed(1)} px）`;
}

/* ==========================
   描画（不揮発モデル）
========================== */
function clearCanvas(context){
  context.clearRect(0,0,context.canvas.width, context.canvas.height);
}
function worldToScreen(p){
  // 世界座標→画面座標（ズームとパンを当てる）
  return { x: p.x * app.scale + app.panX, y: p.y * app.scale + app.panY };
}
function screenToWorld(p){
  return { x:(p.x - app.panX)/app.scale, y:(p.y - app.panY)/app.scale };
}
function drawStroke(st){
  ctx.save();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  ctx.scale(dpr, dpr);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.globalAlpha = st.alpha ?? 1;
  ctx.globalCompositeOperation = st.comp || 'source-over';
  ctx.strokeStyle = st.color || '#fff';
  ctx.fillStyle = st.color || '#fff';
  const w = st.w || 2;
  // 線幅は世界座標pxをそのまま使う（ズームはCSS側）
  ctx.lineWidth = w;

  if (st.type === 'free' || st.type === 'marker') {
    ctx.beginPath();
    st.pts.forEach((pt,i)=>{
      const s = worldToScreen(pt);
      if (i===0) ctx.moveTo(s.x, s.y);
      else ctx.lineTo(s.x, s.y);
    });
    ctx.stroke();
  } else if (st.type === 'line') {
    ctx.beginPath();
    const a = worldToScreen(st.a), b = worldToScreen(st.b);
    ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
  }
  ctx.restore();
}
function drawAll(){
  clearCanvas(ctx);
  app.strokes.forEach(drawStroke);
}
function drawOverlay(preview){
  clearCanvas(octx);
  if (!preview) return;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  octx.save(); octx.scale(dpr, dpr);
  octx.lineCap='round'; octx.lineJoin='round';
  octx.strokeStyle = '#7ec8ff'; octx.fillStyle='#7ec8ff';
  octx.globalAlpha = .9; octx.setLineDash([6,6]);
  octx.lineWidth = (app.penSizePx); // 見た目合わせ
  if (preview.type === 'line' && preview.a && preview.b){
    const a = worldToScreen(preview.a), b = worldToScreen(preview.b);
    octx.beginPath(); octx.moveTo(a.x,a.y); octx.lineTo(b.x,b.y); octx.stroke();
    // 角度注記（UI追加せずオーバーレイに描く）
    const dx = (preview.b.x - preview.a.x), dy = (preview.b.y - preview.a.y);
    const ang = Math.atan2(dy, dx) * 180/Math.PI; // x軸正=0°, CCW=＋, CW=－
    const mid = {x:(a.x+b.x)/2, y:(a.y+b.y)/2};
    octx.setLineDash([]);
    octx.font = '12px system-ui, sans-serif';
    octx.fillStyle = '#ffffff';
    octx.strokeStyle = 'rgba(0,0,0,.6)'; octx.lineWidth=3;
    const text = ang.toFixed(1) + '°';
    octx.strokeText(text, mid.x+8, mid.y-8);
    octx.fillText(text, mid.x+8, mid.y-8);
  }
  octx.restore();
}

/* ==========================
   入力処理（ペン/マーカー/直線/パン）
========================== */
function setTool(name){
  app.tool = name;
  // aria-pressedの反映
  [els.penBtn, els.markerBtn, els.lineBtn, els.handBtn].forEach(b=>b.setAttribute('aria-pressed','false'));
  if (name==='pen') els.penBtn.setAttribute('aria-pressed','true');
  if (name==='marker') els.markerBtn.setAttribute('aria-pressed','true');
  if (name==='line') els.lineBtn.setAttribute('aria-pressed','true');
  if (name==='hand') els.handBtn.setAttribute('aria-pressed','true');
  // 描画中はスナップ無効（段々の線防止）
}

function beginDraw(world){
  app.drawing = true;
  if (app.tool === 'pen' || app.tool === 'marker'){
    app.currentStroke = { type: app.tool==='marker'?'marker':'free', pts:[world], w: app.penSizePx, color:'#fff', alpha: app.tool==='marker'?0.6:1, comp: app.tool==='marker'?'source-over':'source-over' };
  } else if (app.tool === 'line'){
    app.lineStart = world;
  } else if (app.tool === 'hand'){
    app.handStart = { x: world.x, y: world.y, panX: app.panX, panY: app.panY };
  }
}

function moveDraw(world){
  if (!app.drawing) return;
  if (app.tool === 'pen' || app.tool === 'marker'){
    app.currentStroke.pts.push(world);
    // 平滑化：移動平均で段々抑制（軽量）
    if (app.currentStroke.pts.length>=3){
      const n = app.currentStroke.pts.length;
      const p0 = app.currentStroke.pts[n-3], p1 = app.currentStroke.pts[n-2], p2 = app.currentStroke.pts[n-1];
      p1.x = (p0.x+p1.x+p2.x)/3; p1.y=(p0.y+p1.y+p2.y)/3;
    }
    drawAll(); drawOverlay(); // ライブ反映（プレビュー不要）
  } else if (app.tool === 'line'){
    drawAll();
    drawOverlay({type:'line', a: app.lineStart, b: world});
  } else if (app.tool === 'hand'){
    const dx = (world.x - app.handStart.x) * app.scale; // 画面移動量はscale補正
    const dy = (world.y - app.handStart.y) * app.scale;
    app.panX = app.handStart.panX + dx;
    app.panY = app.handStart.panY + dy;
    applyViewTransform();
  }
}

function endDraw(world){
  if (!app.drawing) return;
  if (app.tool === 'pen' || app.tool === 'marker'){
    app.strokes.push(app.currentStroke);
    app.currentStroke = null;
    saveSnapshot();
  } else if (app.tool === 'line'){
    // 直線は確定時のみコミット（ドラッグ中はプレビューで表示）
    app.strokes.push({ type:'line', a: app.lineStart, b: world, w: app.penSizePx, color:'#fff', alpha:1 });
    app.lineStart = null; drawOverlay();
    saveSnapshot();
  }
  app.drawing = false;
}

/* 画面→世界座標 取得ヘルパ（pointer/mouse/touch） */
function getScreenPointFromEvent(e){
  if (e.touches && e.touches[0]) return {x:e.touches[0].clientX, y:e.touches[0].clientY};
  if (e.changedTouches && e.changedTouches[0]) return {x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY};
  return {x:e.clientX, y:e.clientY};
}

/* ==========================
   ズーム（ピンチ＆ボタン表示）
========================== */
function setScale(next, centerScreen){
  const old = app.scale;
  app.scale = Math.max(app.minScale, Math.min(app.maxScale, next));
  // ズーム中心を保つ： (ws-translate) を調整
  if (centerScreen){
    const before = screenToWorld(centerScreen);
    applyViewTransform();
    const after = screenToWorld(centerScreen);
    // ズレを打ち消す
    app.panX += (after.x - before.x) * app.scale;
    app.panY += (after.y - before.y) * app.scale;
  }
  applyViewTransform();
}

function onWheel(e){
  if (!e.ctrlKey) return; // 通常スクロールは無視／Ctrl+ホイールでズーム
  e.preventDefault();
  const delta = -Math.sign(e.deltaY) * app.step;
  const pt = {x:e.clientX, y:e.clientY};
  setScale(app.scale + delta, pt);
}

function onTouchStart(e){
  if (e.touches.length===2){
    e.preventDefault();
    const [a,b] = e.touches;
    const dx = b.clientX - a.clientX, dy = b.clientY - a.clientY;
    app.pinch = {
      d: Math.hypot(dx,dy),
      cx: (a.clientX+b.clientX)/2,
      cy: (a.clientY+b.clientY)/2,
      startScale: app.scale
    };
  } else if (e.touches.length===1){
    const p = {x:e.touches[0].clientX, y:e.touches[0].clientY};
    const world = screenToWorld(p);
    beginDraw(world);
  }
}
function onTouchMove(e){
  if (app.pinch && e.touches.length===2){
    e.preventDefault();
    const [a,b] = e.touches;
    const dx = b.clientX - a.clientX, dy = b.clientY - a.clientY;
    const d = Math.hypot(dx,dy);
    const scale = app.pinch.startScale * (d / app.pinch.d);
    setScale(scale, {x:app.pinch.cx, y:app.pinch.cy});
  } else if (e.touches.length===1 && app.drawing){
    const p = {x:e.touches[0].clientX, y:e.touches[0].clientY};
    moveDraw(screenToWorld(p));
  }
}
function onTouchEnd(e){
  if (app.pinch && e.touches.length<2){ app.pinch = null; }
  if (app.drawing){
    const p = getScreenPointFromEvent(e);
    endDraw(screenToWorld(p));
  }
}

/* ==========================
   永続化（IndexedDB）
========================== */
const DB_NAME='notelink-db', STORE='doc', KEY='latest';
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME,1);
    req.onupgradeneeded = (ev)=>{
      const db = ev.target.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = ()=>resolve(req.result);
    req.onerror = ()=>reject(req.error);
  });
}
async function idbSet(value){
  try{
    const db = await idbOpen();
    const tx = db.transaction(STORE,'readwrite');
    tx.objectStore(STORE).put(value, KEY);
    await new Promise((res,rej)=>{ tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
    db.close();
  }catch(_){}
}
async function idbGet(){
  try{
    const db = await idbOpen();
    const tx = db.transaction(STORE,'readonly');
    const req = tx.objectStore(STORE).get(KEY);
    const val = await new Promise((res,rej)=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });
    db.close();
    return val;
  }catch(_){ return null; }
}
function saveSnapshot(){
  // 差分でなく簡易スナップショット
  const snap = { strokes: app.strokes, scale: app.scale, panX: app.panX, panY: app.panY, penSizePx: app.penSizePx, fontPt: app.fontPt };
  idbSet(JSON.stringify(snap));
}
async function restoreSnapshot(){
  const raw = await idbGet();
  if (!raw) return;
  try{
    const snap = JSON.parse(raw);
    app.strokes = snap.strokes || [];
    app.scale = snap.scale ?? 1;
    app.panX = snap.panX ?? 0; app.panY = snap.panY ?? 0;
    app.penSizePx = snap.penSizePx ?? 2; els.penSize.value = app.penSizePx;
    app.fontPt = snap.fontPt ?? 14; els.fontSize.value = app.fontPt;
    updatePenLabel(); updateFontLabel(); applyViewTransform(); drawAll();
  }catch(_){}
}
// タブ遷移などでも消えない：可視性変化・ページ離脱で保存、復帰で読込
document.addEventListener('visibilitychange',()=>{ if (document.visibilityState==='hidden') saveSnapshot(); });
window.addEventListener('pagehide', saveSnapshot);
window.addEventListener('pageshow', ()=>{ restoreSnapshot(); });

/* ==========================
   ダイアログ（外側タップで閉じない）
========================== */
function openPanel(btn, panel){
  btn.setAttribute('aria-pressed','true');
  btn.classList.add('is-open');
  panel.hidden = false;
}
function closePanel(btn, panel){
  btn.setAttribute('aria-pressed','false');
  btn.classList.remove('is-open');
  panel.hidden = true;
}
// 設定
els.settingsBtn.addEventListener('click', ()=> {
  const open = els.settingsBtn.getAttribute('aria-pressed')==='true';
  (open? closePanel: openPanel)(els.settingsBtn, els.settingsPanel);
}, {passive:true});
els.settingsClose.addEventListener('click', ()=> closePanel(els.settingsBtn, els.settingsPanel), {passive:true});
// キーボード
els.kbdBtn.addEventListener('click', ()=> {
  const open = els.kbdBtn.getAttribute('aria-pressed')==='true';
  (open? closePanel: openPanel)(els.kbdBtn, els.kbdPanel);
}, {passive:true});
els.kbdClose.addEventListener('click', ()=> closePanel(els.kbdBtn, els.kbdPanel), {passive:true});
// 外側タップで閉じるロジックは置かない（仕様）

/* ==========================
   フルスクリーン切替
========================== */
els.fullscreenBtn.addEventListener('click', async ()=>{
  try{
    if (!document.fullscreenElement) {
      await document.documentElement.requestFullscreen();
      els.fullscreenBtn.textContent = '全画面を終了';
    } else {
      await document.exitFullscreen();
      els.fullscreenBtn.textContent = '全画面にする';
    }
  }catch(_){}
}, {passive:true});

/* ==========================
   イベント配線
========================== */
[els.penBtn, els.markerBtn, els.lineBtn, els.handBtn].forEach((btn, i)=>{
  const map = ['pen','marker','line','hand'];
  btn.addEventListener('click', ()=> setTool(map[i]), {passive:true});
});

els.gridBtn.addEventListener('click', ()=>{
  app.grid = !app.grid; els.gridBtn.setAttribute('aria-pressed', app.grid?'true':'false');
  els.workspace.classList.toggle('grid-on', app.grid);
}, {passive:true});

// ズームは表示のみ（±ボタンは追加しない／UI据え置き）。Ctrl+ホイールとピンチ対応。
window.addEventListener('resize', fitCanvas);
els.workspace.addEventListener('wheel', onWheel, {passive:false});

// ポインタイベント（マウス/タッチ対応）
els.workspace.addEventListener('mousedown', (e)=>{
  const p = {x:e.clientX, y:e.clientY}; beginDraw(screenToWorld(p));
});
window.addEventListener('mousemove', (e)=>{ if (!app.drawing) return; moveDraw(screenToWorld({x:e.clientX,y:e.clientY})); });
window.addEventListener('mouseup', (e)=>{ if (!app.drawing) return; endDraw(screenToWorld({x:e.clientX,y:e.clientY})); });

els.workspace.addEventListener('touchstart', onTouchStart, {passive:false});
els.workspace.addEventListener('touchmove', onTouchMove, {passive:false});
els.workspace.addEventListener('touchend', onTouchEnd, {passive:false});
els.workspace.addEventListener('touchcancel', onTouchEnd, {passive:false});

/* ==========================
   コントロール変更
========================== */
els.penSize.addEventListener('input', ()=>{
  app.penSizePx = parseFloat(els.penSize.value);
  updatePenLabel();
}, {passive:true});

els.fontSize.addEventListener('input', ()=>{
  app.fontPt = parseInt(els.fontSize.value, 10);
  updateFontLabel();
}, {passive:true});

/* ==========================
   初期化
========================== */
function init(){
  setTool('pen');
  updatePenLabel(); updateFontLabel();
  fitCanvas();
  applyViewTransform();
  restoreSnapshot();
}
init();
</script>
</body>
</html>
